#bookings_model


from django.db import models
from django.core.validators import MinValueValidator
from decimal import Decimal
import uuid


class AdditionalService(models.Model):
    """Additional services available for booking"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200, verbose_name="Service Name")
    description = models.TextField(blank=True, verbose_name="Description")
    price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Price (UAH)"
    )
    is_active = models.BooleanField(default=True, verbose_name="Is Active")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Additional Service"
        verbose_name_plural = "Additional Services"
        ordering = ['name']

    def __str__(self):
        return f"{self.name} - {self.price} UAH"


class StudioBooking(models.Model):
    """Photo studio booking"""
    STATUS_CHOICES = [
        ('pending_payment', 'Pending Payment'),
        ('paid', 'Paid'),
        ('confirmed', 'Confirmed'),
        ('cancelled', 'Cancelled'),
        ('completed', 'Completed'),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Client Information
    first_name = models.CharField(max_length=100, verbose_name="First Name")
    last_name = models.CharField(max_length=100, verbose_name="Last Name")
    phone_number = models.CharField(max_length=20, verbose_name="Phone Number")
    email = models.EmailField(blank=True, null=True, verbose_name="Email")

    # Booking Details
    booking_date = models.DateField(verbose_name="Booking Date")
    booking_time = models.TimeField(verbose_name="Booking Time")
    duration_hours = models.PositiveIntegerField(
        validators=[MinValueValidator(1)],
        verbose_name="Duration (hours)"
    )

    # Services
    additional_services = models.ManyToManyField(
        AdditionalService,
        blank=True,
        related_name='bookings',
        verbose_name="Additional Services"
    )

    # Pricing
    base_price_per_hour = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Base Price per Hour (UAH)"
    )
    services_total = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        default=Decimal('0.00'),
        verbose_name="Services Total (UAH)"
    )
    total_amount = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Total Amount (UAH)"
    )
    deposit_amount = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Deposit Amount (UAH)"
    )
    deposit_percentage = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=Decimal('30.00'),
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Deposit Percentage"
    )

    # Payment Reference
    payment = models.OneToOneField(
        'payment_service.StudioPayment',  # Reference to your payment module
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='booking',
        verbose_name="Payment"
    )

    # Status and Notes
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending_payment',
        verbose_name="Status"
    )
    notes = models.TextField(blank=True, verbose_name="Notes")
    admin_notes = models.TextField(blank=True, verbose_name="Admin Notes")

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Studio Booking"
        verbose_name_plural = "Studio Bookings"
        ordering = ['-booking_date', '-booking_time']
        indexes = [
            models.Index(fields=['booking_date', 'booking_time']),
            models.Index(fields=['status']),
            models.Index(fields=['phone_number']),
        ]
        # Prevent double booking
        constraints = [
            models.UniqueConstraint(
                fields=['booking_date', 'booking_time'],
                condition=models.Q(status__in=['pending_payment', 'paid', 'confirmed']),
                name='unique_active_booking_datetime'
            )
        ]

    def __str__(self):
        return f"{self.first_name} {self.last_name} - {self.booking_date} {self.booking_time}"

    def calculate_total(self):
        """Calculate total amount based on duration and services"""
        base_total = self.base_price_per_hour * self.duration_hours
        services_total = sum(
            service.price for service in self.additional_services.all()
        )
        return base_total + services_total

    def calculate_deposit(self):
        """Calculate deposit amount"""
        return (self.total_amount * self.deposit_percentage) / Decimal('100.00')

    def get_end_time(self):
        """Calculate booking end time"""
        from datetime import datetime, timedelta

        if not self.booking_date or not self.booking_time:
            return None  # prevents crash if data isn't set yet

        start_datetime = datetime.combine(self.booking_date, self.booking_time)
        end_datetime = start_datetime + timedelta(hours=self.duration_hours)
        return end_datetime.time()


class BookingSettings(models.Model):
    """Global settings for booking system"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Pricing
    base_price_per_hour = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        default=Decimal('500.00'),
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Base Price per Hour (UAH)"
    )
    deposit_percentage = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=Decimal('30.00'),
        validators=[MinValueValidator(Decimal('0.01'))],
        verbose_name="Deposit Percentage"
    )

    # Working Hours
    opening_time = models.TimeField(default='09:00', verbose_name="Opening Time")
    closing_time = models.TimeField(default='21:00', verbose_name="Closing Time")

    # Booking Rules
    min_booking_hours = models.PositiveIntegerField(
        default=1,
        validators=[MinValueValidator(1)],
        verbose_name="Minimum Booking Hours"
    )
    max_booking_hours = models.PositiveIntegerField(
        default=8,
        validators=[MinValueValidator(1)],
        verbose_name="Maximum Booking Hours"
    )
    advance_booking_days = models.PositiveIntegerField(
        default=60,
        validators=[MinValueValidator(1)],
        verbose_name="Advance Booking Days"
    )

    # Maintenance
    is_booking_enabled = models.BooleanField(
        default=True,
        verbose_name="Booking Enabled"
    )
    maintenance_message = models.TextField(
        blank=True,
        verbose_name="Maintenance Message"
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Booking Settings"
        verbose_name_plural = "Booking Settings"

    def __str__(self):
        return "Booking Settings"

    @classmethod
    def get_settings(cls):
        """Get or create singleton settings instance"""
        settings, created = cls.objects.get_or_create(
            pk=cls.objects.first().pk if cls.objects.exists() else uuid.uuid4())
        return settings


# bookings_services

from datetime import datetime, date, time, timedelta
from typing import List, Dict, Tuple
from decimal import Decimal
from .models import StudioBooking, BookingSettings, AdditionalService
from django.db.models import Q


class BookingAvailabilityService:
    """Service for checking booking availability"""

    def __init__(self):
        self.settings = BookingSettings.get_settings()

    def get_available_slots(
            self,
            check_date: date,
            duration_hours: int
    ) -> List[Dict]:
        """
        Get all available time slots for a given date and duration.
        Returns list of dicts with start_time, end_time, and available status.
        """
        if check_date < date.today():
            return []

        # Get existing bookings for the date
        existing_bookings = StudioBooking.objects.filter(
            booking_date=check_date,
            status__in=['pending_payment', 'paid', 'confirmed']
        ).order_by('booking_time')

        # Generate potential time slots (hourly intervals)
        available_slots = []
        current_time = self.settings.opening_time

        while True:
            # Calculate slot end time
            start_datetime = datetime.combine(check_date, current_time)
            end_datetime = start_datetime + timedelta(hours=duration_hours)
            end_time = end_datetime.time()

            # Check if slot extends past closing time
            if end_time > self.settings.closing_time:
                break

            # Check if slot conflicts with existing bookings
            is_available = self._check_slot_availability(
                check_date,
                current_time,
                end_time,
                existing_bookings
            )

            available_slots.append({
                'start_time': current_time.strftime('%H:%M'),
                'end_time': end_time.strftime('%H:%M'),
                'available': is_available
            })

            # Move to next hour
            next_datetime = start_datetime + timedelta(hours=1)
            current_time = next_datetime.time()

            if current_time >= self.settings.closing_time:
                break

        return available_slots

    def _check_slot_availability(
            self,
            check_date: date,
            start_time: time,
            end_time: time,
            existing_bookings
    ) -> bool:
        """Check if a specific time slot is available"""
        slot_start = datetime.combine(check_date, start_time)
        slot_end = datetime.combine(check_date, end_time)

        for booking in existing_bookings:
            booking_start = datetime.combine(check_date, booking.booking_time)
            booking_end = booking_start + timedelta(hours=booking.duration_hours)

            # Check for overlap
            if slot_start < booking_end and slot_end > booking_start:
                return False

        return True

    def is_slot_available(
            self,
            booking_date: date,
            booking_time: time,
            duration_hours: int,
            exclude_booking_id: str = None
    ) -> Tuple[bool, str]:
        """
        Check if a specific slot is available.
        Returns (is_available, message)
        """
        # Check date validity
        if booking_date < date.today():
            return False, "Cannot book dates in the past"

        max_date = date.today() + timedelta(days=self.settings.advance_booking_days)
        if booking_date > max_date:
            return False, f"Cannot book more than {self.settings.advance_booking_days} days in advance"

        # Check working hours
        if booking_time < self.settings.opening_time:
            return False, f"Studio opens at {self.settings.opening_time}"

        # Calculate end time
        start_datetime = datetime.combine(booking_date, booking_time)
        end_datetime = start_datetime + timedelta(hours=duration_hours)
        end_time = end_datetime.time()

        if end_time > self.settings.closing_time:
            return False, f"Booking extends past closing time ({self.settings.closing_time})"

        # Check conflicts
        conflicts = StudioBooking.objects.filter(
            booking_date=booking_date,
            status__in=['pending_payment', 'paid', 'confirmed']
        )

        if exclude_booking_id:
            conflicts = conflicts.exclude(id=exclude_booking_id)

        for conflict in conflicts:
            conflict_start = datetime.combine(booking_date, conflict.booking_time)
            conflict_end = conflict_start + timedelta(hours=conflict.duration_hours)

            if start_datetime < conflict_end and end_datetime > conflict_start:
                return False, f"Time slot conflicts with existing booking at {conflict.booking_time}"

        return True, "Slot is available"

    def get_next_available_slot(
            self,
            start_date: date,
            duration_hours: int,
            days_to_check: int = 7
    ) -> Dict:
        """Find the next available slot starting from a given date"""
        current_date = start_date
        end_date = start_date + timedelta(days=days_to_check)

        while current_date <= end_date:
            slots = self.get_available_slots(current_date, duration_hours)
            available = [s for s in slots if s['available']]

            if available:
                return {
                    'date': current_date.isoformat(),
                    'time_slot': available[0]
                }

            current_date += timedelta(days=1)

        return None


class BookingCalculationService:
    """Service for price calculations"""

    @staticmethod
    def calculate_booking_cost(
            duration_hours: int,
            additional_service_ids: List[str] = None,
            settings: BookingSettings = None
    ) -> Dict[str, Decimal]:
        """
        Calculate total cost, deposit, and breakdown.
        Returns dict with base_cost, services_cost, total, deposit.
        """
        if settings is None:
            settings = BookingSettings.get_settings()

        base_cost = settings.base_price_per_hour * duration_hours
        services_cost = Decimal('0.00')

        if additional_service_ids:
            services = AdditionalService.objects.filter(
                id__in=additional_service_ids,
                is_active=True
            )
            services_cost = sum(service.price for service in services)

        total = base_cost + services_cost
        deposit = (total * settings.deposit_percentage) / Decimal('100.00')

        return {
            'base_cost': base_cost,
            'services_cost': services_cost,
            'total_amount': total,
            'deposit_amount': deposit.quantize(Decimal('0.01')),
            'deposit_percentage': settings.deposit_percentage
        }


class BookingManagementService:
    """Service for managing booking lifecycle"""

    @staticmethod
    def cancel_booking(booking: StudioBooking, reason: str = None) -> bool:
        """Cancel a booking"""
        if booking.status in ['completed', 'cancelled']:
            return False

        booking.status = 'cancelled'
        if reason:
            booking.admin_notes = f"{booking.admin_notes}\nCancellation reason: {reason}"
        booking.save()

        return True

    @staticmethod
    def confirm_booking(booking: StudioBooking) -> bool:
        """Confirm a paid booking"""
        if booking.status != 'paid':
            return False

        booking.status = 'confirmed'
        booking.save()

        return True

    @staticmethod
    def complete_booking(booking: StudioBooking) -> bool:
        """Mark booking as completed"""
        if booking.status != 'confirmed':
            return False

        booking.status = 'completed'
        booking.save()

        return True

    @staticmethod
    def update_payment_status(booking: StudioBooking) -> bool:
        """Update booking status based on payment status"""
        if not booking.payment:
            return False

        if booking.payment.is_paid and booking.status == 'pending_payment':
            booking.status = 'paid'
            booking.save()
            return True

        return False

    @staticmethod
    def get_upcoming_bookings(days: int = 7) -> List[StudioBooking]:
        """Get all upcoming bookings"""
        today = date.today()
        end_date = today + timedelta(days=days)

        return StudioBooking.objects.filter(
            booking_date__range=[today, end_date],
            status__in=['paid', 'confirmed']
        ).order_by('booking_date', 'booking_time')

    @staticmethod
    def get_bookings_by_status(status: str) -> List[StudioBooking]:
        """Get bookings by status"""
        return StudioBooking.objects.filter(status=status).order_by('-created_at')


# bookings_views

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from django.shortcuts import get_object_or_404
from django.db import transaction
from datetime import date, datetime

from .models import StudioBooking, AdditionalService, BookingSettings
from .serializers import (
    StudioBookingSerializer,
    AdditionalServiceSerializer,
    BookingSettingsSerializer,
    AvailabilityCheckSerializer,
    AvailableSlotSerializer,
    AdminBookingSerializer
)
from .services import (
    BookingAvailabilityService,
    BookingCalculationService,
    BookingManagementService
)

# Import your payment services
from payment_service.models import StudioPayment
from payment_service.services import LiqPayService


class AdditionalServiceViewSet(viewsets.ReadOnlyModelViewSet):
    """
    ViewSet for listing additional services.
    Only active services are shown to regular users.
    """
    serializer_class = AdditionalServiceSerializer
    permission_classes = [AllowAny]

    def get_queryset(self):
        if self.request.user.is_staff:
            return AdditionalService.objects.all()
        return AdditionalService.objects.filter(is_active=True)


class BookingAvailabilityViewSet(viewsets.ViewSet):
    """
    ViewSet for checking booking availability.
    """
    permission_classes = [AllowAny]

    @action(detail=False, methods=['post'], url_path='check-availability')
    def check_availability(self, request):
        """
        Check available time slots for a specific date and duration.

        POST data:
        {
            "date": "2025-11-15",
            "duration_hours": 2
        }
        """
        serializer = AvailabilityCheckSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        check_date = serializer.validated_data['date']
        duration_hours = serializer.validated_data['duration_hours']

        service = BookingAvailabilityService()
        available_slots = service.get_available_slots(check_date, duration_hours)

        return Response({
            'date': check_date,
            'duration_hours': duration_hours,
            'slots': available_slots
        })

    @action(detail=False, methods=['post'], url_path='is-slot-available')
    def is_slot_available(self, request):
        """
        Check if a specific time slot is available.

        POST data:
        {
            "booking_date": "2025-11-15",
            "booking_time": "14:00",
            "duration_hours": 2
        }
        """
        booking_date = request.data.get('booking_date')
        booking_time = request.data.get('booking_time')
        duration_hours = request.data.get('duration_hours')

        if not all([booking_date, booking_time, duration_hours]):
            return Response(
                {'error': 'Missing required fields'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            booking_date = datetime.strptime(booking_date, '%Y-%m-%d').date()
            booking_time = datetime.strptime(booking_time, '%H:%M').time()
            duration_hours = int(duration_hours)
        except (ValueError, TypeError):
            return Response(
                {'error': 'Invalid date/time format'},
                status=status.HTTP_400_BAD_REQUEST
            )

        service = BookingAvailabilityService()
        is_available, message = service.is_slot_available(
            booking_date,
            booking_time,
            duration_hours
        )

        return Response({
            'available': is_available,
            'message': message
        })

    @action(detail=False, methods=['post'], url_path='calculate-cost')
    def calculate_cost(self, request):
        """
        Calculate booking cost with optional services.

        POST data:
        {
            "duration_hours": 2,
            "additional_service_ids": ["uuid1", "uuid2"]
        }
        """
        duration_hours = request.data.get('duration_hours')
        additional_service_ids = request.data.get('additional_service_ids', [])

        if not duration_hours:
            return Response(
                {'error': 'duration_hours is required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            duration_hours = int(duration_hours)
        except (ValueError, TypeError):
            return Response(
                {'error': 'Invalid duration_hours'},
                status=status.HTTP_400_BAD_REQUEST
            )

        cost_breakdown = BookingCalculationService.calculate_booking_cost(
            duration_hours,
            additional_service_ids
        )

        return Response(cost_breakdown)


class StudioBookingViewSet(viewsets.ModelViewSet):
    """
    ViewSet for managing studio bookings.
    """
    serializer_class = StudioBookingSerializer
    permission_classes = [AllowAny]  # Change to IsAuthenticated in production

    def get_queryset(self):
        if self.request.user.is_staff:
            return StudioBooking.objects.all()
        # Regular users can only see their own bookings (filter by phone or email)
        phone = self.request.query_params.get('phone_number')
        if phone:
            return StudioBooking.objects.filter(phone_number=phone)
        return StudioBooking.objects.none()

    def get_serializer_class(self):
        if self.request.user.is_staff and self.action in ['list', 'retrieve']:
            return AdminBookingSerializer
        return StudioBookingSerializer

    @transaction.atomic
    def create(self, request, *args, **kwargs):
        """
        Create a new booking and initiate payment.

        Steps:
        1. Validate booking data
        2. Create booking record
        3. Create payment record
        4. Generate LiqPay payment form
        5. Return booking and payment info
        """
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # Create booking
        booking = serializer.save()

        # Create payment for deposit
        payment = StudioPayment.objects.create(
            amount=booking.deposit_amount,
            description=f"Deposit for booking {booking.id} - {booking.first_name} {booking.last_name} on {booking.booking_date}"
        )

        # Link payment to booking
        booking.payment = payment
        booking.save()

        # Generate LiqPay payment form
        liqpay_service = LiqPayService()
        payment_form_data = liqpay_service.generate_payment_form(payment)

        return Response({
            'booking': StudioBookingSerializer(booking).data,
            'payment': {
                'payment_id': str(payment.id),
                'amount': str(payment.amount),
                'liqpay_data': payment_form_data
            }
        }, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['get'], url_path='check-payment-status')
    def check_payment_status(self, request, pk=None):
        """Check the payment status of a booking"""
        booking = self.get_object()

        if not booking.payment:
            return Response({
                'status': 'no_payment',
                'message': 'No payment associated with this booking'
            })

        # Update booking status based on payment
        BookingManagementService.update_payment_status(booking)
        booking.refresh_from_db()

        return Response({
            'booking_status': booking.status,
            'payment': {
                'is_paid': booking.payment.is_paid,
                'liqpay_status': booking.payment.liqpay_status,
                'checkbox_status': booking.payment.checkbox_status
            }
        })

    @action(detail=False, methods=['get'], url_path='my-bookings')
    def my_bookings(self, request):
        """Get bookings by phone number or email"""
        phone = request.query_params.get('phone_number')
        email = request.query_params.get('email')

        if not phone and not email:
            return Response(
                {'error': 'phone_number or email is required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        queryset = StudioBooking.objects.none()

        if phone:
            queryset = StudioBooking.objects.filter(phone_number=phone)
        elif email:
            queryset = StudioBooking.objects.filter(email=email)

        queryset = queryset.order_by('-booking_date', '-booking_time')
        serializer = self.get_serializer(queryset, many=True)

        return Response(serializer.data)

    # Admin actions
    @action(
        detail=True,
        methods=['post'],
        url_path='confirm',
        permission_classes=[IsAuthenticated]
    )
    def confirm_booking(self, request, pk=None):
        """Admin: Confirm a paid booking"""
        booking = self.get_object()

        if BookingManagementService.confirm_booking(booking):
            return Response({
                'status': 'confirmed',
                'message': 'Booking confirmed successfully'
            })

        return Response({
            'error': 'Booking cannot be confirmed'
        }, status=status.HTTP_400_BAD_REQUEST)

    @action(
        detail=True,
        methods=['post'],
        url_path='cancel',
        permission_classes=[IsAuthenticated]
    )
    def cancel_booking(self, request, pk=None):
        """Admin: Cancel a booking"""
        booking = self.get_object()
        reason = request.data.get('reason', '')

        if BookingManagementService.cancel_booking(booking, reason):
            return Response({
                'status': 'cancelled',
                'message': 'Booking cancelled successfully'
            })

        return Response({
            'error': 'Booking cannot be cancelled'
        }, status=status.HTTP_400_BAD_REQUEST)

    @action(
        detail=True,
        methods=['post'],
        url_path='complete',
        permission_classes=[IsAuthenticated]
    )
    def complete_booking(self, request, pk=None):
        """Admin: Mark booking as completed"""
        booking = self.get_object()

        if BookingManagementService.complete_booking(booking):
            return Response({
                'status': 'completed',
                'message': 'Booking completed successfully'
            })

        return Response({
            'error': 'Booking cannot be completed'
        }, status=status.HTTP_400_BAD_REQUEST)

    @action(
        detail=False,
        methods=['post'],
        url_path='admin-create',
        permission_classes=[IsAuthenticated]
    )
    @transaction.atomic
    def admin_create(self, request):
        """
        Admin: Create booking without payment validation.

        Allows staff to create bookings directly with any status.
        """
        if not request.user.is_staff:
            return Response(
                {'error': 'Only staff can create bookings directly'},
                status=status.HTTP_403_FORBIDDEN
            )

        serializer = AdminBookingSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # Get or set pricing from settings if not provided
        settings = BookingSettings.get_settings()
        if 'base_price_per_hour' not in serializer.validated_data:
            serializer.validated_data['base_price_per_hour'] = settings.base_price_per_hour
        if 'deposit_percentage' not in serializer.validated_data:
            serializer.validated_data['deposit_percentage'] = settings.deposit_percentage

        # Extract additional services
        additional_service_ids = request.data.get('additional_service_ids', [])

        # Create booking
        booking = StudioBooking.objects.create(**serializer.validated_data)

        # Add additional services
        if additional_service_ids:
            services = AdditionalService.objects.filter(
                id__in=additional_service_ids,
                is_active=True
            )
            booking.additional_services.set(services)
            booking.services_total = sum(service.price for service in services)

        # Calculate totals if not manually set
        if 'total_amount' not in serializer.validated_data:
            booking.total_amount = booking.calculate_total()
        if 'deposit_amount' not in serializer.validated_data:
            booking.deposit_amount = booking.calculate_deposit()

        booking.save()

        return Response(
            AdminBookingSerializer(booking).data,
            status=status.HTTP_201_CREATED
        )


class BookingSettingsViewSet(viewsets.ViewSet):
    """
    ViewSet for booking settings.
    """
    permission_classes = [AllowAny]

    def list(self, request):
        """Get current booking settings"""
        settings = BookingSettings.get_settings()
        serializer = BookingSettingsSerializer(settings)
        return Response(serializer.data)

    @action(detail=False, methods=['put'], permission_classes=[IsAuthenticated])
    def update_settings(self, request):
        """Admin: Update booking settings"""
        settings = BookingSettings.get_settings()
        serializer = BookingSettingsSerializer(settings, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

# bookings_serializers

from rest_framework import serializers
from .models import StudioBooking, AdditionalService, BookingSettings
from datetime import datetime, date, time, timedelta
from decimal import Decimal

from clothing.serializers import (
    BookingClothingItemSerializer,
    BookingClothingItemCreateSerializer
)
from clothing.services import ClothingBookingService


from props.serializers import (
    BookingPropItemSerializer,
    BookingPropItemCreateSerializer
)
from props.services import PropBookingService


class AdditionalServiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = AdditionalService
        fields = ['id', 'name', 'description', 'price', 'is_active']
        read_only_fields = ['id']


class BookingSettingsSerializer(serializers.ModelSerializer):
    class Meta:
        model = BookingSettings
        fields = [
            'base_price_per_hour',
            'deposit_percentage',
            'opening_time',
            'closing_time',
            'min_booking_hours',
            'max_booking_hours',
            'advance_booking_days',
            'is_booking_enabled',
            'maintenance_message'
        ]


class StudioBookingSerializer(serializers.ModelSerializer):
    additional_services = AdditionalServiceSerializer(many=True, read_only=True)
    additional_service_ids = serializers.ListField(
        child=serializers.UUIDField(),
        write_only=True,
        required=False
    )

    clothing_items = BookingClothingItemCreateSerializer(
        many=True,
        write_only=True,
        required=False,
        allow_empty=True
    )
    clothing_items_display = BookingClothingItemSerializer(
        source='clothing_items',
        many=True,
        read_only=True
    )
    clothing_summary = serializers.SerializerMethodField()

    prop_items = BookingPropItemCreateSerializer(
        many=True,
        write_only=True,
        required=False,
        allow_empty=True
    )
    prop_items_display = BookingPropItemSerializer(
        source='prop_items',
        many=True,
        read_only=True
    )
    prop_summary = serializers.SerializerMethodField()

    end_time = serializers.SerializerMethodField()
    payment_status = serializers.SerializerMethodField()



    class Meta:
        model = StudioBooking
        fields = [
            'id',
            'first_name',
            'last_name',
            'phone_number',
            'email',
            'booking_date',
            'booking_time',
            'duration_hours',
            'additional_services',
            'additional_service_ids',
            'clothing_items',
            'clothing_items_display',
            'clothing_summary',
            'prop_items',
            'prop_items_display',
            'prop_summary',
            'base_price_per_hour',
            'services_total',
            'total_amount',
            'deposit_amount',
            'deposit_percentage',
            'status',
            'notes',
            'end_time',
            'payment_status',
            'created_at',
            'updated_at'
        ]
        read_only_fields = [
            'id',
            'base_price_per_hour',
            'services_total',
            'total_amount',
            'deposit_amount',
            'deposit_percentage',
            'status',
            'end_time',
            'payment_status',
            'clothing_items_display',
            'clothing_summary',
            'prop_items_display',
            'prop_summary',
            'created_at',
            'updated_at'
        ]


    def get_end_time(self, obj):
        return obj.get_end_time()

    def get_payment_status(self, obj):
        if obj.payment:
            return {
                'is_paid': obj.payment.is_paid,
                'liqpay_status': obj.payment.liqpay_status,
                'checkbox_status': obj.payment.checkbox_status
            }
        return None

    def get_clothing_summary(self, obj):
        """Get summary of clothing rental costs"""
        try:
            service = ClothingBookingService()
            return service.get_booking_clothing_summary(obj)
        except:
            return None

    def validate_clothing_items(self, value):
        """Validate clothing items don't exceed limit"""
        if value and len(value) > 10:
            raise serializers.ValidationError(
                "Не можна додати більше 10 одиниць одягу до одного бронювання"
            )
        return value

    def get_prop_summary(self, obj):
        """Get summary of prop rental costs"""
        try:
            service = PropBookingService()
            return service.get_booking_prop_summary(obj)
        except:
            return None

    def validate_prop_items(self, value):
        """Validate prop items don't exceed limit"""
        if value and len(value) > 20:
            raise serializers.ValidationError(
                "Cannot add more than 20 prop items to a single booking"
            )
        return value

    def validate_booking_date(self, value):
        """Validate booking date is in the future and within allowed range"""
        today = date.today()
        settings = BookingSettings.get_settings()

        if value < today:
            raise serializers.ValidationError("Cannot book dates in the past")

        max_date = today + timedelta(days=settings.advance_booking_days)
        if value > max_date:
            raise serializers.ValidationError(
                f"Cannot book more than {settings.advance_booking_days} days in advance"
            )

        return value

    def validate_duration_hours(self, value):
        """Validate duration is within allowed range"""
        settings = BookingSettings.get_settings()

        if value < settings.min_booking_hours:
            raise serializers.ValidationError(
                f"Minimum booking duration is {settings.min_booking_hours} hour(s)"
            )

        if value > settings.max_booking_hours:
            raise serializers.ValidationError(
                f"Maximum booking duration is {settings.max_booking_hours} hour(s)"
            )

        return value

    def validate(self, data):
        """Validate booking doesn't conflict with existing bookings"""
        settings = BookingSettings.get_settings()

        if not settings.is_booking_enabled:
            raise serializers.ValidationError(
                settings.maintenance_message or "Booking is currently disabled"
            )

        booking_date = data.get('booking_date')
        booking_time = data.get('booking_time')
        duration_hours = data.get('duration_hours')

        # Validate time is within working hours
        if booking_time < settings.opening_time:
            raise serializers.ValidationError({
                'booking_time': f"Studio opens at {settings.opening_time}"
            })

        # Calculate end time
        start_datetime = datetime.combine(booking_date, booking_time)
        end_datetime = start_datetime + timedelta(hours=duration_hours)
        end_time = end_datetime.time()

        if end_time > settings.closing_time:
            raise serializers.ValidationError({
                'duration_hours': f"Booking would extend past closing time ({settings.closing_time})"
            })

        # Check for conflicts with existing bookings
        conflicts = StudioBooking.objects.filter(
            booking_date=booking_date,
            status__in=['pending_payment', 'paid', 'confirmed']
        ).exclude(id=self.instance.id if self.instance else None)

        for conflict in conflicts:
            conflict_start = datetime.combine(booking_date, conflict.booking_time)
            conflict_end = conflict_start + timedelta(hours=conflict.duration_hours)

            # Check if times overlap
            if (start_datetime < conflict_end and end_datetime > conflict_start):
                raise serializers.ValidationError({
                    'booking_time': f"Time slot conflicts with existing booking at {conflict.booking_time}"
                })

        clothing_items = data.get('clothing_items', [])
        if clothing_items:
            from clothing.services import ClothingAvailabilityService
            service = ClothingAvailabilityService()

            is_valid, errors = service.validate_booking_items(
                clothing_items,
                booking_date,
                booking_time,
                duration_hours,
                exclude_booking_id=str(self.instance.id) if self.instance else None
            )

            if not is_valid:
                raise serializers.ValidationError({
                    'clothing_items': errors
                })

        prop_items = data.get('prop_items', [])
        if prop_items:
            from props.services import PropAvailabilityService
            service = PropAvailabilityService()

            is_valid, errors = service.validate_booking_items(
                prop_items,
                booking_date,
                booking_time,
                duration_hours,
                exclude_booking_id=str(self.instance.id) if self.instance else None
            )

            if not is_valid:
                raise serializers.ValidationError({
                    'prop_items': errors
                })

        return data

    def create(self, validated_data):
        """Create booking with calculated prices"""
        additional_service_ids = validated_data.pop('additional_service_ids', [])

        clothing_items = validated_data.pop('clothing_items', [])

        prop_items = validated_data.pop('prop_items', [])

        settings = BookingSettings.get_settings()

        # Set pricing from settings
        validated_data['base_price_per_hour'] = settings.base_price_per_hour
        validated_data['deposit_percentage'] = settings.deposit_percentage

        # Create booking
        booking = StudioBooking.objects.create(**validated_data)

        # Add additional services
        if additional_service_ids:
            services = AdditionalService.objects.filter(
                id__in=additional_service_ids,
                is_active=True
            )
            booking.additional_services.set(services)
            booking.services_total = sum(service.price for service in services)

        # Calculate totals
        booking.total_amount = booking.calculate_total()
        booking.deposit_amount = booking.calculate_deposit()
        booking.save()

        if clothing_items:
            clothing_service = ClothingBookingService()
            success, errors, clothing_cost = clothing_service.add_clothing_to_booking(
                booking,
                clothing_items
            )

            if success and clothing_cost > 0:
                # Update booking total to include clothing
                booking.total_amount += clothing_cost
                booking.deposit_amount = booking.calculate_deposit()
                booking.save(update_fields=['total_amount', 'deposit_amount'])

                # Update payment amount if payment exists
                if booking.payment:
                    booking.payment.amount = booking.deposit_amount
                    booking.payment.save(update_fields=['amount'])

        if prop_items:
            prop_service = PropBookingService()
            success, errors, prop_cost = prop_service.add_props_to_booking(
                booking,
                prop_items
            )

            if success and prop_cost > 0:
                # Update booking total to include props
                booking.total_amount += prop_cost
                booking.deposit_amount = booking.calculate_deposit()
                booking.save(update_fields=['total_amount', 'deposit_amount'])

                # Update payment amount if payment exists
                if booking.payment:
                    booking.payment.amount = booking.deposit_amount
                    booking.payment.save(update_fields=['amount'])

        return booking


class AvailabilityCheckSerializer(serializers.Serializer):
    """Serializer for checking availability"""
    date = serializers.DateField()
    duration_hours = serializers.IntegerField(min_value=1, max_value=24)

    def validate_date(self, value):
        if value < date.today():
            raise serializers.ValidationError("Cannot check availability for past dates")
        return value


class AvailableSlotSerializer(serializers.Serializer):
    """Serializer for available time slots"""
    start_time = serializers.TimeField()
    end_time = serializers.TimeField()
    available = serializers.BooleanField()


class AdminBookingSerializer(serializers.ModelSerializer):
    """Extended serializer for admin views"""
    additional_services = AdditionalServiceSerializer(many=True, read_only=True)
    additional_service_ids = serializers.ListField(
        child=serializers.UUIDField(),
        write_only=True,
        required=False
    )
    end_time = serializers.SerializerMethodField()
    payment_details = serializers.SerializerMethodField()

    class Meta:
        model = StudioBooking
        fields = '__all__'
        read_only_fields = ['id', 'created_at', 'updated_at']

    def get_end_time(self, obj):
        return obj.get_end_time()

    def get_payment_details(self, obj):
        if obj.payment:
            return {
                'payment_id': str(obj.payment.id),
                'amount': str(obj.payment.amount),
                'is_paid': obj.payment.is_paid,
                'liqpay_status': obj.payment.liqpay_status,
                'checkbox_receipt_id': obj.payment.checkbox_receipt_id,
                'checkbox_fiscal_code': obj.payment.checkbox_fiscal_code,
                'checkbox_status': obj.payment.checkbox_status
            }
        return None

    # Disable validation for admin
    def validate(self, data):
        return data

